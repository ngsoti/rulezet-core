const VulnerabilityInput = {
    props: {
        modelValue: { type: Array, default: () => [] },
        targetType: { type: String, default: 'bundle' },
        targetId: { type: [String, Number], default: null },
        placeholder: { type: String, default: 'Select type or type ID...' },
        label: { type: String, default: 'Vulnerability Identifiers' }
    },
    emits: ['update:modelValue'],
    delimiters: ['[[', ']]'],
    setup(props, { emit }) {
        const rawText = Vue.ref('');
        const detectedItems = Vue.ref([...props.modelValue]);
        const isDropdownOpen = Vue.ref(false);
      
        const fetchVulnerabilities = async (id) => {
            if (!id || id === 'None' || id === '') return;
            
            const url = props.targetType === 'rule' 
                ? `/rule/get_rule_vulnerabilities_display/${id}`
                : `/bundle/vulnerabilities/${props.targetType}/${id}`;

            try {
                const response = await fetch(url);
                if (response.ok) {
                    const data = await response.json(); 
                    if (data.success && Array.isArray(data.vulnerabilities)) {
                        detectedItems.value = data.vulnerabilities;
                    } else if (Array.isArray(data)) {
                        detectedItems.value = data;
                    }
                    emit('update:modelValue', [...detectedItems.value]);
                }
            } catch (error) {
                console.error("Critical: Could not fetch vulnerabilities:", error);
            }
        };

        Vue.watch(() => props.targetId, (newId) => {
            if (newId && newId !== 'None' && newId !== '' && detectedItems.value.length === 0) {
                fetchVulnerabilities(newId);
            }
        }, { immediate: true });

        const vulnerabilityTypes = [
            { name: 'CVE', prefix: 'CVE-' },
            { name: 'GHSA', prefix: 'GHSA-' },
            { name: 'PYSEC', prefix: 'PYSEC-' },
            { name: 'GSD', prefix: 'GSD-' },
            { name: 'GCVE', prefix: 'GCVE-' },
            { name: 'RHSA', prefix: 'RHSA-' },
            { name: 'CERTFR', prefix: 'CERTFR-' },
            { name: 'Cisco', prefix: 'cisco-sa-' },
            { name: 'MSRC', prefix: 'msrc_CVE-' }
        ];

        const v_pattern = /^(CVE[-\s]\d{4}[-\s]\d{4,7}|GCVE-\d+-\d{4}-\d+|GHSA-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}|PYSEC-\d{4}-\d{2,5}|GSD-\d{4}-\d{4,5}|wid-sec-w-\d{4}-\d{4}|cisco-sa-\d{8}-[a-zA-Z0-9]+|RHSA-\d{4}:\d{4}|msrc_CVE-\d{4}-\d{4,}|CERTFR-\d{4}-[A-Z]{3}-\d{3})$/i;

        const getCVEColor = (cve) => {
            if (cve.startsWith("CVE")) return "bg-danger text-white";
            if (cve.startsWith("GHSA")) return "bg-warning text-dark";
            if (cve.startsWith("PYSEC")) return "bg-info text-dark";
            if (cve.startsWith("GSD")) return "bg-secondary text-white";
            if (cve.startsWith("GCVE")) return "bg-primary text-white";
            if (cve.startsWith("RHSA")) return "bg-danger-subtle text-dark border border-danger-subtle";
            if (cve.startsWith("CERTFR")) return "bg-success text-white";
            if (cve.startsWith("cisco-sa")) return "bg-dark text-white";
            if (cve.startsWith("wid-sec-w")) return "bg-secondary text-white";
            if (cve.startsWith("msrc_CVE")) return "bg-purple text-white";
            return "bg-dark text-white";
        };

        const getCVEIcon = (cve) => {
            if (cve.startsWith("CVE")) return "fas fa-shield-alt";
            if (cve.startsWith("GHSA")) return "fas fa-bug";
            if (cve.startsWith("PYSEC")) return "fas fa-code";
            if (cve.startsWith("GSD")) return "fas fa-database";
            if (cve.startsWith("GCVE")) return "fas fa-globe";
            if (cve.startsWith("RHSA")) return "fas fa-lock";
            if (cve.startsWith("CERTFR")) return "fas fa-flag";
            if (cve.startsWith("cisco-sa")) return "fas fa-network-wired";
            if (cve.startsWith("wid-sec-w")) return "fas fa-exclamation-circle";
            if (cve.startsWith("msrc_CVE")) return "fas fa-shield-virus";
            return "fas fa-exclamation-triangle";
        };

        const getCVEPrefix = (cve) => cve.split("-")[0].toUpperCase();
        const getCVENumber = (cve) => cve.replace(/^[A-Za-z_:-]+/, "").replace(/^-/, "");

        const isEntryValid = Vue.computed(() => {
            const val = rawText.value.trim();
            return val !== "" && v_pattern.test(val);
        });

        const selectType = (prefix) => {
            rawText.value = prefix;
            isDropdownOpen.value = false;
            Vue.nextTick(() => document.getElementById('vulnerability-raw-input')?.focus());
        };

        const addManual = (event) => {
            const val = rawText.value.trim().toUpperCase();
            if (v_pattern.test(val)) {
                if (!detectedItems.value.includes(val)) {
                    detectedItems.value.push(val);
                    emit('update:modelValue', [...detectedItems.value]);
                }
                rawText.value = '';
                const target = event ? event.currentTarget : null;
                if (target) {
                    target.classList.add('animate__animated', 'animate__pulse');
                    setTimeout(() => target.classList.remove('animate__pulse'), 500);
                }
            }
        };

        const removeTag = (item) => {
            detectedItems.value = detectedItems.value.filter(i => i !== item);
            emit('update:modelValue', [...detectedItems.value]);
        };

        const closeDropdown = (e) => {
            if (!e.target.closest('.dropdown')) isDropdownOpen.value = false;
        };

        Vue.onMounted(() => window.addEventListener('click', closeDropdown));
        Vue.onUnmounted(() => window.removeEventListener('click', closeDropdown));

        return { 
            rawText, detectedItems, isEntryValid, addManual, 
            removeTag, vulnerabilityTypes, selectType, isDropdownOpen,
            getCVEColor, getCVEIcon, getCVEPrefix, getCVENumber
        };
    },
    template: `
    <div class="vulnerability-input-container text-start">
        <label class="form-label fw-bold text-muted small text-uppercase">[[ label ]]</label>
        
        <div class="input-group shadow-sm rounded-3 border overflow-visible" 
             :style="{ borderColor: isEntryValid === true ? '#28a745' : (rawText.length > 3 ? '#dc3545' : '#dee2e6'), borderWidth: '2px' }">
            
            <div class="dropdown">
                <button class="btn btn-light border-end h-100 px-3 dropdown-toggle" 
                        type="button" @click.stop="isDropdownOpen = !isDropdownOpen">
                    Format
                </button>
                <ul class="dropdown-menu shadow-lg border-0 p-2" :class="{ 'show': isDropdownOpen }" 
                    style="display: block; position: absolute; z-index: 1060; max-height: 250px; overflow-y: auto;" 
                    v-if="isDropdownOpen">
                    <li v-for="type in vulnerabilityTypes" :key="type.name">
                        <a class="dropdown-item rounded-2 py-2" href="#" @click.prevent="selectType(type.prefix)">
                            <i :class="getCVEIcon(type.prefix)" class="me-2 text-muted"></i>
                            <strong>[[ type.name ]]</strong>
                        </a>
                    </li>
                </ul>
            </div>

            <input id="vulnerability-raw-input" type="text" v-model="rawText" 
                @keydown.enter.prevent="addManual" class="form-control border-0 shadow-none px-3" 
                :placeholder="placeholder" style="height: 46px;">
            
            <button class="btn px-3" :class="isEntryValid ? 'btn-success text-white' : 'btn-light text-muted'"
                    type="button" @click="addManual" :disabled="!isEntryValid">
                <i class="fas fa-plus"></i>
            </button>
        </div>

        <div class="d-flex flex-wrap gap-2 mt-3">
            <div v-for="item in detectedItems" :key="item" 
                 class="d-flex align-items-center rounded-2 shadow-sm animate__animated animate__fadeIn" 
                 :class="getCVEColor(item)" style="font-size: 0.85rem; font-family: monospace; overflow: hidden;">
                
                <div class="px-2 py-1 bg-black bg-opacity-10 text-white border-end border-white border-opacity-10">
                    <i :class="getCVEIcon(item)"></i>
                </div>
                
                <div class="px-2 py-1 fw-bold">
                    <span class="opacity-75">[[ getCVEPrefix(item) ]]</span>-[[ getCVENumber(item) ]]
                </div>

                <div class="px-2 py-1 bg-black bg-opacity-10" @click="removeTag(item)" style="cursor:pointer">
                    <i class="fas fa-times"></i>
                </div>
            </div>
        </div>

        <div class="mt-2" style="height: 20px;">
            <small v-if="rawText.length > 3 && !isEntryValid" class="text-danger fw-bold">
                <i class="fas fa-times-circle me-1"></i> Invalid format for [[ getCVEPrefix(rawText) ]]
            </small>
            <small v-else-if="isEntryValid" class="text-success fw-bold">
                <i class="fas fa-check-circle me-1"></i> Format Correct
            </small>
        </div>
    </div>
    `
};
export default VulnerabilityInput;